# 분할 상환 분석

대부분의 경우, 알고리즘의 시간 복잡도는 그 알고리즘의 구조를 파악하는 것만으로도 쉽게 분석이 가능하지만, 분석을 했을 때
알고리즘의 시간 복잡도가 제대로 드러나지 않는 경우도 있다. 분할 상환 분석 (amortized analysis)은 시간 복잡도가 일정하지
않은 연산이 포함된 알고리즘의 시간 복잡도를 알고 싶을 때 사용할 수 있는 기법으로, 각각의 연산에 집중하는 대신 모든 연산
을 실행하는 데 걸린 총 시간을 계산하여 시간 복잡도를 파악한다.

## 투 포인터 알고리즘

투 포인터 알고리즘 (two pointers algorithm)은 서로 다른 부분 배열을 선택할 때 사용할 수 있는 알고리즘으로, 두 개의
포인터가 배열의 각 원소를 선택하여 연속적인 부분 배열을 만드는 방식이다. 왼쪽 끝에서 시작하는 포인터는 항상 오른쪽으로 
움직이고, 오른쪽 끝에서 시작하는 포인터는 항상 왼쪽으로 움직이기 때문에 상당히 효율적인 알고리즘이라고 할 수 있다.

## 부분 배열의 합

투 포인터 알고리즘을 사용해 풀 수 있는 대표적인 문제로 부분 배열의 합 (subarray sum) 문제가 있다. 이 문제는 모든 원소가
자연수인 배열과 `x`라는 수가 주어졌을 때, 모든 원소의 합이 `x`가 되는 부분 배열을 찾는 문제이다. 투 포인터 알고리즘을
사용하면 이 문제를 `O(n)` 시간 안에 해결할 수 있다. 먼저, 두 개의 포인터가 배열의 첫 번째 원소와 맨 마지막 원소를
가리키도록 한다. 그런 다음, 부분 배열의 모든 원소의 합이 `x`가 될 때까지 두 개의 포인터를 각각 오른쪽과 왼쪽으로 한 칸씩
움직이며 합을 계속 비교한다. 이 알고리즘의 실행 시간은 맨 마지막 원소에서 시작하는 포인터가 몇 칸 움직이는지에 따라
달라지지만, 왼쪽과 오른쪽 포인터는 항상 `O(n)` 시간과 비례하여 움직이기 때문에 이 알고리즘의 시간 복잡도는 `O(n)`이 된다.

## 2SUM

투 포인터 알고리즘을 사용해 풀 수 있는 또다른 문제로는 2SUM 문제가 있는데, 부분 배열의 합과 비슷하게 모든 원소가 자연수인 
배열과 `x`라는 수가 주어졌을 때에 합이 `x`가 되는 배열의 두 수를 찾는 문제이다. 이 문제를 풀기 위해서는 먼저 배열을
오름차순으로 정렬한 다음, 두 개의 포인터를 이용해 조건을 만족하는 두 수를 선택해야 한다. 선택한 두 수가 `x`보다 작으면 
왼쪽 포인터를 오른쪽으로 한 칸 이동하고, `x`보다 클 경우에는 오른쪽 포인터를 왼쪽으로 한 칸 이동하다보면 조건을 만족하는
두 수를 구할 수 있다. 이 알고리즘의 시간 복잡도는 `O(n * log n)`인데, 배열을 정렬하는 데에 `O(n * log n)`의 시간이 걸리고
두 개의 포인터가 움직이는 데에 `O(n)`의 시간이 걸리기 때문이다. 

## 슬라이딩 윈도우

슬라이딩 윈도우 (sliding window)는 어떤 배열의 처음부터 끝까지 움직이는 크기가 고정된 부분 배열을 말한다.
