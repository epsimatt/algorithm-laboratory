# 욕심쟁이 알고리즘

욕심쟁이 알고리즘 (greedy algorithm)은 매 순간마다 가장 나아 보이는 것을 선택하는 문제 해결 방법이다. 욕심쟁이
알고리즘에서는 가장 나아 보이는 것을 선택한 이후에 절대 그 결정을 바꾸지 않으며, 그 선택을 가지고 바로 문제를 해결한다.
욕심쟁이 알고리즘은 상당히 효율적인 문제 해결 방법으로 알려져 있지만, 문제를 해결할 수 있는 최적의 선택을
찾는 것이 어렵다는 문제가 있다. 또한 욕심쟁이 알고리즘은 적용할 수 있는 문제가 그렇게 많지 않다는 문제를 가진다.

욕심쟁이 알고리즘을 적용할 수 있는 대표적인 문제는 동전 문제 (coin problem)이다. 동전 문제는 다양한 종류의 동전을 개수
제한 없이 사용하여 선택한 동전의 합이 `n`이 되도록 하기 위해 필요한 최소한의 동전 개수를 구하는 문제이다. 주어진 동전이
`{1, 2, 5, 10, 20, 50, 100, 200}`이고, `n = 520`일 때, 이 문제를 욕심쟁이 알고리즘을 이용해서 해결하려면 `200`짜리
동전 2개를 먼저 선택하고, `100`짜리 동전 1개와 `20`짜리 동전 1개를 선택하면 된다. 하지만 욕심쟁이 알고리즘으로 항상
최적의 문제 해결 방법을 얻을 수 있는 것은 아니다. 주어진 동전이 `{1, 3, 4}`이고 `n = 6`일 경우, 욕심쟁이 알고리즘을
사용하면 해답이 `4 + 1 + 1`이 나오지만 실제 해답은 `3 + 3`이 나오는 것을 확인할 수 있다.

## 이진 코드
이진 코드 (binary code)는 알파벳의 각 문자를 이진수에 대응시켜 문자를 표현하는 방식으로, 문자열을 압축하는 데에 사용될
수 있다. 문자열을 효율적으로 압축하는 방법은 문자에 대응하는 이진수의 길이를 고정 (constant-length)하는 대신에 길이를
다양하게 조절 (variable-length)하여 사용하는 것이다. 예를 들면, 문자 A, B, C, D를 `00`,`01`, `10`, `11`와 대응시키면
문자열 `AABACDACA`는 `000001001011001000`로 나타낼 수 있지만, 문자 A, B, C, D를 `0`, `110`, `10`, `111`과 대응시키면
같은 문자열을 `001100101110100`로, 더 짧게 나타낼 수 있다.

## 허프만 코딩
허프만 코딩 (huffman coding)은 욕심쟁이 알고리즘을 사용해 주어진 문자열을 효율적으로 압축하는 기법이다. 이 알고리즘은
문자열에 포함된 문자의 개수를 기반으로 하여 이진 트리 (binary tree)를 만든다. 이진 트리의 루트 노드 (root node)에서부터
시작해 문자에 대응하는 노드까지 계속 트리를 따라가다 보면 주어진 문자에 대응하는 코드를 구할 수 있다. 하나의 노드에서
그 아래 노드로 이동할 경우, 왼쪽에 있는 노드는 비트 `0`과, 오른쪽에 있는 노드는 비트 `1`과 대응한다.

허프만 코드의 첫 단계는 문자열의 각 문자를 노드로 나타내는 것이다. 이때 문자와 대응하는 노드의 가중치는 그 문자가
문자열에서 나타나는 횟수로 정한다. 그 다음 단계에서는 최소 가중치를 가진 두 개의 노드를 합쳐 가중치가 노드 두 개의
무게를 합한 값이 되는 새로운 노드를 만든다. 모든 노드가 합쳐질 때까지 이 작업은 계속 진행된다.