# 비트 조작

프로그래밍에서, n비트 정수는 n개의 비트로 이루어진 2진수로 컴퓨터에 저장된다. 예를 들면, C++에서 `int` 자료형의 크기는
32비트인데, 이것은 모든 `int` 자료형의 숫자가 32비트로 이루어져 있다는 것을 의미한다.

`int` 자료형 정수 43을 32개의 비트로 나타내면 `00000000000000000000000000101011`이다. n개의 비트로 부호 있는 정수를
나타낼 때, n개의 비트는 `-2 ^ (n - 1)`부터 `2 ^ (n - 1) - 1`까지의 수를 나타낼 수 있으며, 부호 없는 정수를 나타낼 때는
n개의 비트가 `0`부터 `2 ^ n - 1`까지의 수를 나타낼 수 있다.

컴퓨터는 2의 보수를 사용하여 음수를 나타내는데, 2의 보수를 사용하여 음수를 나타낼 때는 양의 정수의 모든 비트를 반전시키고
그 수에 1을 더하면 된다. 이 방법을 사용하여 -43을 32개의 비트로 나타내면 `11111111111111111111111111010101`이다.

## 비트 표현
집합 `{0, 1, 2, ..., n - 1}`의 부분집합은 n개의 비트로 나타낼 수 있는데, 이때 1은 집합의 몇 번째 원소가 부분집합에 속하는
지를 나타낸다. 예를 들어, 집합 `{0, 1, 2, ..., 31}`의 부분집합 `{1, 3, 4, 8}`을 32개의 비트로 나타내면
`00000000000000000000000100011010`이 된다.

```python
# 길이가 같은 두 문자열 `a`, `b`의 해밍 거리를 구한다.
def hamming_distance(a: str, b: str):
    distance = 0

    for i in range(0, len(a)):
        if a[i] is not b[i]:
            distance += 1

    return distance


# `x`를 32개의 비트로 나타낸다.
def print_binary_32bit(x: int):
    result = ""

    for i in range(0, 32):
        result += '1' if x & (1 << i) else '0'

    print(result[::-1])


if __name__ == '__main__':
    x = 43

    # `x`를 32비트 정수로 변환한다.
    print(x & 0xffffffff)

    # `x`가 홀수이면 1, 짝수이면 0을 출력한다.
    print(x & 1)

    # `x`를 32개의 비트로 나타낸다.
    print_binary_32bit(x)

    # `x`의 3번째 비트를 1로 바꾼다.
    print(f"x: {bin(x)} -> {bin(x | (1 << 2))}")

    # `x`의 2번째 비트를 0으로 바꾼다.
    print(f"x: {bin(x)} -> {bin(x & ~(1 << 1))}")

    # `x`의 마지막 비트를 제외한 모든 비트를 1에서 0으로 바꾼다.
    print(x & -x)

    # `x`가 2의 `k`제곱인지 확인한다. (단, `k` >= 0)
    print(x & (x - 1))
```